(globalThis.webpackChunk=globalThis.webpackChunk||[]).push([[856],{3905:(e,t,a)=>{"use strict";a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(a),m=r,k=c["".concat(s,".").concat(m)]||c[m]||d[m]||i;return a?n.createElement(k,l(l({ref:t},p),{},{components:a})):n.createElement(k,l({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},26e3:(e,t,a)=>{"use strict";a.d(t,{q:()=>i});var n=a(67294);const r="sideBySide_3jwM";function i({children:e}){const t=n.Children.count(e);if(2!==t)throw new Error(`Invalid SideBySide children count: ${t}`);const[a,i]=n.Children.toArray(e);return n.createElement("div",{className:r},a,i)}},86914:(e,t,a)=>{"use strict";a.r(t),a.d(t,{frontMatter:()=>l,metadata:()=>o,toc:()=>s,default:()=>p});var n=a(22122),r=(a(67294),a(3905)),i=a(26e3);const l={title:"Language extensions"},o={unversionedId:"advanced/language-extensions",id:"advanced/language-extensions",isDocsHomePage:!1,title:"Language extensions",description:"TypeScriptToLua provides several extensions to the TypeScript language in the form of types and helper functions. To use these language extensions, add the types to your tsconfig.json:",source:"@site/docs/advanced/language-extensions.md",sourceDirName:"advanced",slug:"/advanced/language-extensions",permalink:"/TypeScriptToLua.github.io/docs/advanced/language-extensions",editUrl:"https://github.com/TypeScriptToLua/TypeScriptToLua.github.io/edit/source/docs/advanced/language-extensions.md",version:"current",frontMatter:{title:"Language extensions"},sidebar:"docs",previous:{title:"Compiler Annotations",permalink:"/TypeScriptToLua.github.io/docs/advanced/compiler-annotations"},next:{title:"Unit Testing",permalink:"/TypeScriptToLua.github.io/docs/advanced/automated-testing"}},s=[{value:"LuaMultiReturn Type",id:"luamultireturn-type",children:[{value:"$multi",id:"multi",children:[]}]},{value:"$range Iterator Function",id:"range-iterator-function",children:[]},{value:"LuaIterable Type",id:"luaiterable-type",children:[]},{value:"Operator Map Types",id:"operator-map-types",children:[{value:"Supported Operators:",id:"supported-operators",children:[]}]},{value:"Lua Table Types",id:"lua-table-types",children:[{value:"Generic key and value types",id:"generic-key-and-value-types",children:[]},{value:"Getting and Setting",id:"getting-and-setting",children:[]},{value:"Iterating",id:"iterating",children:[]},{value:"Custom Getters and Setters",id:"custom-getters-and-setters",children:[]},{value:"All custom LuaTable functions",id:"all-custom-luatable-functions",children:[]}]},{value:"$vararg Constant",id:"vararg-constant",children:[]}],u={toc:s};function p({components:e,...t}){return(0,r.kt)("wrapper",(0,n.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TypeScriptToLua provides several extensions to the TypeScript language in the form of types and helper functions. To use these language extensions, add the types to your ",(0,r.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json",metastring:"title=tsconfig.json",title:"tsconfig.json"},'{\n    "compilerOptions": {\n        ...\n        "types": ["typescript-to-lua/language-extensions"],\n        ...\n    },\n}\n')),(0,r.kt)("h2",{id:"luamultireturn-type"},"LuaMultiReturn Type"),(0,r.kt)("p",null,"This language extension allows typing of Lua functions that return multiple values. For example, consider Lua's ",(0,r.kt)("inlineCode",{parentName:"p"},"string.find"),", it returns two indices: the start of the found substring and the end of the found substring. In TypeScript, functions can only return one value so a special type is needed to indicate to tstl there are multiple return values. This is the ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaMultiReturn<>")," type."),(0,r.kt)("p",null,"It allows us to declare ",(0,r.kt)("inlineCode",{parentName:"p"},"string.find")," like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=stringfind.ts",title:"stringfind.ts"},'declare namespace string {\n  export function find(haystack: string, needle: string): LuaMultiReturn<[number, number]>;\n}\n\nconst [start, end] = string.find("Hello, world!", "world");\n')),(0,r.kt)("p",null,"Translating into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua",metastring:"title=stringfind.lua",title:"stringfind.lua"},'start, ____end = string.find("Hello, world!", "world")\n')),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Prefer LuaMultiReturn over the similar ",(0,r.kt)("a",{parentName:"p",href:"/TypeScriptToLua.github.io/docs/advanced/compiler-annotations#tuplereturn"},"@tupleReturn annotation"),". LuaMultiReturn can do anything tupleReturn can, with the added benefit of being able to distinguish between actual tuple tables and multiple return values in the type system."))),(0,r.kt)("h3",{id:"multi"},"$multi"),(0,r.kt)("p",null,"In order to create a function that returns multiple values it needs to return a ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaMultiReturn<>")," type. This is where the ",(0,r.kt)("inlineCode",{parentName:"p"},"$multi")," function comes in. Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"$multi")," in a return statement will create an instance of the ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaMultiReturn<>")," type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=multi.ts",title:"multi.ts"},'function myFunc(): LuaMultiReturn<[string, number]> {\n  return $multi("foo", 4);\n}\n\nconst [foo, four] = myFunc();\n')),(0,r.kt)("p",null,"Translates into:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua",metastring:"title=multi.lua",title:"multi.lua"},'function myFunc(self)\n    return "foo", 4\nend\nfoo, four = myFunc(nil)\n')),(0,r.kt)("h2",{id:"range-iterator-function"},"$range Iterator Function"),(0,r.kt)("p",null,"TypeScript's numeric for loops are less restrictive than Lua's, so they are transpiled into while loops instead. To create a Lua-style numeric for loop, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"$range")," language extension in a for...of loop."),(0,r.kt)("p",null,"Example:"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"for (const i of $range(1, 5)) {}\nfor (const i of $range(1, 10, 2)) {}\nfor (const i of $range(5, 1, -1)) {}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"for i = 1, 5 do end\nfor i = 1, 10, 2 do end\nfor i = 5, 1, -1 do end\n"))),(0,r.kt)("h2",{id:"luaiterable-type"},"LuaIterable Type"),(0,r.kt)("p",null,"Iterators in Lua work quite differently than in TypeScript/JavaScript, so a special type is needed to use them."),(0,r.kt)("p",null,"For example, to declare and use a Lua function that returns an iterator for a set of strings, you can do this:"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare function myIterator(): LuaIterable<string>;\n\nfor (const s of myIterator()) {\n  console.log(s);\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"for s in myIterator() do\n  print(s)\nend\n"))),(0,r.kt)("p",null,"Some iterators return multiple values each iteration. To declare these, combine ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaIterable")," with ",(0,r.kt)("a",{parentName:"p",href:"#luamultireturn-type"},(0,r.kt)("inlineCode",{parentName:"a"},"LuaMultiReturn")),":"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare function myIterator(): LuaIterable<LuaMultiReturn<[string, string]>>;\n\nfor (const [a, b] of myIterator()) {\n  console.log(a, b);\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"for a, b in myIterator() do\n  print(a, b)\nend\n"))),(0,r.kt)("p",null,"Lua iterators support passing an invisible state object each iteration. If your iterator type does this, you can declare the state type as a second type parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type MyStateType = ...\ndeclare function myIterator(): LuaIterable<string, MyStateType>;\n")),(0,r.kt)("p",null,"This is only really required if you need to use the iterator outside of a ",(0,r.kt)("inlineCode",{parentName:"p"},"for...of")," loop."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"let [iteratorFunction, state, lastValue] = myIterator();\nwhile (true) {\n  const value = iteratorFunction(state, lastValue);\n  console.log(value);\n  lastValue = value;\n}\n")),(0,r.kt)("p",null,"See the ",(0,r.kt)("a",{parentName:"p",href:"https://www.lua.org/manual/5.3/manual.html#3.3.5"},"Lua Reference Manual")," for more information on Lua for loops."),(0,r.kt)("h2",{id:"operator-map-types"},"Operator Map Types"),(0,r.kt)("p",null,"Lua supports overloading operators on types using ",(0,r.kt)("a",{parentName:"p",href:"https://www.lua.org/manual/5.4/manual.html#2.4"},"metatable methods")," such as ",(0,r.kt)("inlineCode",{parentName:"p"},"__add"),". But, JavaScript and TypeScript do not support this. In order to use overloaded operators on types that support them, you can declare special mapping functions in TS that will translate to those operators in Lua."),(0,r.kt)("p",null,"A common example of an overloaded operator is addition of a mathematical vector type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Vector type supplied by a library, which supports math operators\ndeclare interface Vector {\n  x: number;\n  y: number;\n}\n\ndeclare const a: Vector;\ndeclare const b: Vector;\nconst result = a + b; // Not allowed in TS\n")),(0,r.kt)("p",null,"To support addition for this type, you can declare a special function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare const addVector: LuaAddition<Vector, Vector, Vector>;\nconst result = addVector(a, b); // transpiles to 'result = a + b'\n")),(0,r.kt)("p",null,"The mapping function does not have to be declared as global. For example, you could use declaration merging to declare it as a static function on ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare namespace Vector {\n  export const add: LuaAddition<Vector, Vector, Vector>;\n}\n\nconst result = Vector.add(a, b); // result = a + b\n")),(0,r.kt)("p",null,"There are also special variants for the mapping types that allow you do declare operator overloads as methods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare interface Vector {\n  add: LuaAdditionMethod<Vector, Vector>;\n}\nconst result = a.add(b); // result = a + b\n")),(0,r.kt)("p",null,"Some operators may have a different return type based on their inputs. You can support this by using intersection types. For example, our ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector")," type might overload the multiplication operator to scale by a number, or perform a dot product on two ",(0,r.kt)("inlineCode",{parentName:"p"},"Vectors"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"declare namespace Vector {\n  export const mul: LuaMultiplication<Vector, Vector, number> & LuaMultiplication<Vector, number, Vector>;\n}\n\nconst dot: number = Vector.mul(a, b);\nconst scaled: Vector = Vector.mul(a, 2);\n")),(0,r.kt)("h3",{id:"supported-operators"},"Supported Operators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Math operators",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"LuaAddition / LuaAdditionMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a + b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaSubtraction / LuaSubtractionMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a - b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaMultiplication / LuaMultiplicationMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a * b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaDivision / LuaDivisionMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a / b "),")"),(0,r.kt)("li",{parentName:"ul"},"LuaModulo / LuaModuloMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a % b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaPower / LuaPowerMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a ^ b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaFloorDivision / LuaFloorDivisionMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a // b"),", only when targeting Lua 5.3 or later)"),(0,r.kt)("li",{parentName:"ul"},"LuaNegation / LuaNegationMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"-x"),")"))),(0,r.kt)("li",{parentName:"ul"},"Bitwise operators (only when targeting Lua 5.3 or later)",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"LuaBitwiseAnd / LuaBitwiseAndMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a & b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaBitwiseOr / LuaBitwiseOrMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a | b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaBitwiseExclusiveOr / LuaBitwiseExclusiveOrMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a ~ b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaBitwiseLeftShift / LuaBitwiseLeftShiftMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a << b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaBitwiseRightShift / LuaBitwiseRightShiftMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a >> b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaBitwiseNot / LuaBitwiseNotMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"~x"),")"))),(0,r.kt)("li",{parentName:"ul"},"LuaConcat / LuaConcatMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"a .. b"),")"),(0,r.kt)("li",{parentName:"ul"},"LuaLength / LuaLengthMethod (",(0,r.kt)("inlineCode",{parentName:"li"},"#x"),")")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"You can also map functions to table accessors (",(0,r.kt)("inlineCode",{parentName:"p"},"__index")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"__newindex"),"). See ",(0,r.kt)("a",{parentName:"p",href:"#lua-table-types"},"Lua Table Types"),"."))),(0,r.kt)("h2",{id:"lua-table-types"},"Lua Table Types"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTable")," type is provided to allow direct creation and manipulation of Lua tables. This is useful if you want to use a table that uses types other than string for its keys, as that is not supported by TypeScript. Calls to lua method tables are translated to simple lua:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"table.get(key)")," Get a value by key -> ",(0,r.kt)("inlineCode",{parentName:"li"},"table[key]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"table.set(key, value)")," Set a value for key -> ",(0,r.kt)("inlineCode",{parentName:"li"},"table[key] = value")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"table.has(key)")," Check if key is in table -> ",(0,r.kt)("inlineCode",{parentName:"li"},"table[key] ~= nil")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"table.delete(key)")," Remove key (and its value) from table -> ",(0,r.kt)("inlineCode",{parentName:"li"},"table[key] = nil"))),(0,r.kt)("h3",{id:"generic-key-and-value-types"},"Generic key and value types"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"LuaTable")," can be used without explicitly providing types for the keys and values, but also allows you to specify the type of keys and values in the table:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const typedLuaTable = new LuaTable<KeyType, ValueType>();\nconst untypedLuaTable = new LuaTable(); // Same as LuaTable<AnyNotNil, any>\n")),(0,r.kt)("h3",{id:"getting-and-setting"},"Getting and Setting"),(0,r.kt)("p",null,"Calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"set")," on the table will transpile directly to ",(0,r.kt)("inlineCode",{parentName:"p"},"value = table[key]")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"table[key] = value"),"."),(0,r.kt)("p",null,"Example:"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const tbl = new LuaTable();\n\ntbl.set("foo", "bar");\nconsole.log(tbl.get("foo"));\n\nconst objectKey = {};\ntbl.set(objectKey, "baz");\nconsole.log(tbl.get(objectKey));\n\ntbl.set(1, "bah");\nconsole.log(tbl.length());\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'tbl = {}\n\ntbl.foo = "bar"\nprint(tbl.foo)\n\nobjectKey = {}\ntbl[objectKey] = "baz"\nprint(tbl[objectKey])\n\ntbl[1] = "bah"\nprint(#tbl)\n'))),(0,r.kt)("h3",{id:"iterating"},"Iterating"),(0,r.kt)("p",null,"To iterate over a ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTable"),", use ",(0,r.kt)("inlineCode",{parentName:"p"},"pairs()"),". (This requires the ",(0,r.kt)("inlineCode",{parentName:"p"},"lua-types")," library to be installed.)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const tbl = new LuaTable<number, string>();\n\ntbl.set(3, "bar");\ntbl.set(4, "bar");\ntbl.set(5, "bar");\n\nfor (const [key, value] of pairs(tbl)) {\n  print(key);\n  print(value);\n}\n')),(0,r.kt)("p",null,"(Remember that in Lua, ",(0,r.kt)("inlineCode",{parentName:"p"},"pairs()")," returns the keys in a random order.)"),(0,r.kt)("h3",{id:"custom-getters-and-setters"},"Custom Getters and Setters"),(0,r.kt)("p",null,"If you have a type that uses non-string keys, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTableGet")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTableSet")," function types to declare your own getters & setters, similar to ",(0,r.kt)("a",{parentName:"p",href:"#operator-map-types"},"Operator Map Types"),"."),(0,r.kt)("p",null,"Example:"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'interface Id {\n  idStr: string;\n}\n\ninterface IdDictionary {\n  get: LuaTableGetMethod<Id, string>;\n  set: LuaTableSetMethod<Id, string>;\n}\n\ndeclare const dict: IdDictionary;\nconst id: Id = { idStr: "foo" };\ndict.set(id, "bar");\nconsole.log(dict.get(id));\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'id = {idStr = "foo"}\ndict[id] = "bar"\nprint(dict[id])\n'))),(0,r.kt)("p",null,"That example uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"Method")," versions of ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTableGet")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTableSet"),". There are also stand-alone versions."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'declare const idGet: LuaTableGet<IdDictionary, Id, string>;\ndeclare const idSet: LuaTableSet<IdDictionary, Id, string>;\nidSet(dict, id, "bar");\nconsole.log(idGet(dict, id));\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'declare namespace IdDictionary {\n  export const get: LuaTableGet<IdDictionary, Id, string>;\n  export const set: LuaTableSet<IdDictionary, Id, string>;\n}\nIdDictionary.set(dict, id, "bar");\nconsole.log(IdDictionary.get(dict, id));\n')),(0,r.kt)("h3",{id:"all-custom-luatable-functions"},"All custom LuaTable functions"),(0,r.kt)("p",null,"There are more LuaTable functions other than ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTableGet")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LuaTableSet")," that you can use:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableGet")," - Standalone function that gets a value by key from a table."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableGetMethod")," - Method that gets a value by key from the table containing this method."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableSet")," - Standlone function that sets a value to a key in a table."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableSetMethod")," - Method that sets a value to a key in the table containing this method."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableHas")," - Standalone function that checks if a key is present in a table."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableHasMethod")," - Method that checks if a key is present in the table containing this method."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableDelete")," - Standalone function that removes a key and its value from a table."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LuaTableDeleteMethod")," - Method that removes a key and its value from table containing this method.")),(0,r.kt)("h2",{id:"vararg-constant"},"$vararg Constant"),(0,r.kt)("p",null,"Lua allows use of the ellipsis operator (",(0,r.kt)("inlineCode",{parentName:"p"},"..."),") to access command line arguments passed when executing a script file. To access this from TypeScript, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"$vararg")," constant in a spread expression."),(0,r.kt)("p",null,"Example:"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"console.log(...$vararg);\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"print(...)\n"))),(0,r.kt)("p",null,"When run:"),(0,r.kt)(i.q,{mdxType:"SideBySide"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> lua myscript.lua foo bar\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"foo     bar\n"))),(0,r.kt)("p",null,"Use of ",(0,r.kt)("inlineCode",{parentName:"p"},"$vararg")," is only allowed at file scope, and only in a spread expression (",(0,r.kt)("inlineCode",{parentName:"p"},"...$vararg"),")."))}p.isMDXComponent=!0}}]);